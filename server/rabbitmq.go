package main

import (
	"fmt"
	"log"

	"github.com/streadway/amqp"
)

func (m *Manager) connectRabbitMQ(uri string) error {
	var err error
	m.amqpConn, err = amqp.Dial(uri) // makes a tcp connection to the rabbitmq server
	if err != nil {
		return fmt.Errorf("failed to connect to RabbitMQ: %w", err)
	}
	// channels are lightweight connections that share a single TCP connection
	// Most AMQP operations (publishing, consuming, declaring queues/exchanges) happen over a channel
	m.amqpChannel, err = m.amqpConn.Channel()
	if err != nil {
		m.amqpConn.Close()
		return fmt.Errorf("failed to open a channel: %w", err)
	}

	err = m.amqpChannel.ExchangeDeclare(
		broadcastExchange, // name: A constant defining the exchange name
		"fanout",          // type: The exchange type
		true,              // durable: Exchange survives broker restarts
		false,             // auto-deleted: Exchange is NOT deleted when no longer in use
		false,             // internal: Exchange can be published to by clients
		false,             // no-wait: The server will send a reply if successful
		nil,               // arguments: No special arguments
	)
	if err != nil {
		m.amqpChannel.Close()
		m.amqpConn.Close()
		return fmt.Errorf("failed to declare broadcast exchange: %w", err)
	}
	log.Println("RabbitMQ connected and broadcast exchange declared.")
	return nil

}
func (m *Manager) publishToRabbitMQ(exchange, routingKey string, body []byte) error {
	if m.amqpChannel == nil {
		return fmt.Errorf("RabbitMQ channel is not initialized")
	}
	err := m.amqpChannel.Publish(
		exchange,   // exchange: Name of the exchange to publish to
		routingKey, // routing key: For fanout, this is ignored. For direct/topic, it's used for routing.
		false,      // mandatory: If true, message is returned to publisher if it can't be routed.
		false,      // immediate: If true, message is returned if no consumer is ready. (Deprecated in newer RabbitMQ)
		amqp.Publishing{ // The message content and properties
			ContentType: "application/json", // Indicates the body format
			Body:        body,               // The actual message payload
		})

	if err != nil {
		return fmt.Errorf("failed to publish message to RabbitMQ: %w", err)
	}
	// log.Printf("Published message to RabbitMQ exchange '%s': %s\n", exchange, string(body))
	return nil
}

func (m *Manager) consumeFromRabbitMQ() {
	if m.amqpChannel == nil {
		log.Println("Cannot consume from RabbitMQ: channel not initialized.")
		return
	}

	// 1. Declare a unique, auto-delete, exclusive queue
	q, err := m.amqpChannel.QueueDeclare(
		"",    // name: Empty means RabbitMQ generates a unique name
		false, // durable: Queue will NOT survive broker restarts
		true,  // delete when unused (auto-delete): Queue is deleted when last consumer unsubscribes
		true,  // exclusive: Used by only one connection and the queue will be deleted when that connection closes
		false, // no-wait: Server will confirm queue declaration
		nil,   // arguments
	)
	if err != nil {
		log.Printf("Failed to declare a queue: %v\n", err)
		return
	}

	// 2. Bind the queue to the fanout exchange
	err = m.amqpChannel.QueueBind(
		q.Name,            // queue name: The unique name generated by RabbitMQ
		"",                // routing key: Ignored for fanout exchanges
		broadcastExchange, // exchange: The fanout exchange to bind to
		false,             // no-wait
		nil,               // arguments
	)
	if err != nil {
		log.Printf("Failed to bind queue '%s' to exchange '%s': %v\n", q.Name, broadcastExchange, err)
		return
	}
	log.Printf("Declared queue '%s' and bound to exchange '%s'\n", q.Name, broadcastExchange)

	// 3. Register a consumer on the queue
	msgs, err := m.amqpChannel.Consume(
		q.Name, // queue: The name of the queue to consume from
		"",     // consumer: Consumer tag (empty for a server-generated tag)
		true,   // auto-ack: Messages are automatically acknowledged upon delivery
		false,  // exclusive: If true, only this consumer can access the queue
		false,  // no-local: If true, server won't send messages published by this connection back to it
		false,  // no-wait: Server will confirm consumer registration
		nil,    // args
	)
	if err != nil {
		log.Printf("Failed to register a consumer: %v\n", err)
		return
	}

	log.Println("RabbitMQ consumer started. Waiting for messages...")
	// 4. Message processing loop
	for {
		select {
		case <-m.shutdownChan: // Listen for manager shutdown
			log.Println("RabbitMQ consumer shutting down.")
			return
		case d, ok := <-msgs: // Receive messages from RabbitMQ
			if !ok {
				log.Println("RabbitMQ consumer channel closed by server.")
				// Potentially attempt to reconnect or handle error gracefully
				return
			}
			// Send this message to all locally connected WebSocket clients (via m.broadcast)
			select {
			case m.broadcast <- d.Body: // Try to send to local broadcast channel
				log.Println("Sent to broadcast channel.")
			default:
				// If local broadcast channel is full, drop the message to avoid blocking RabbitMQ consumer
				log.Printf("Local broadcast channel full. Dropping message from RabbitMQ: %s\n", string(d.Body))
			}
		}
	}
}
